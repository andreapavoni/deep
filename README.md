# If you can't _Fly_ it's better to go Deep

Deep is a minimal micro PaaS for a single VPS. It runs apps as containers, tracks releases in SQLite, and routes traffic with a containerized Caddy instance.

The core flow is intentionally simple:

1) Initialize the host.
2) Add an app and `app.toml`.
3) Deploy a container image.
4) Roll back when needed.

Everything else is optional.

## Where commands run

- **Laptop**: build images and push to a registry (optional if you build on the host).
- **VPS (host)**: run all `deep` commands (host init, app management, deploys, rollbacks).

## Requirements (VPS)
- Git and Podman available + systemd and quadlets enabled on the host
- A registry **or** build-on-push (optional) for images

## Quickstart

### 1) VPS: host setup

```bash
deep host init
```

`deep host init` creates directories, the Podman network, and a Caddy quadlet.
By default, Caddy binds to ports 80/443 and the quadlet will be system-level
unless unprivileged ports are enabled.
`--data-dir` is optional and defaults to `/srv/deep`.

If you want a user quadlet with low ports, set
`net.ipv4.ip_unprivileged_port_start=0` or use higher ports (e.g. 8080/8443).
By default, ports below 1024 will select a system quadlet.

Run `deep` as the same user that owns the quadlets. If Caddy runs as a system unit, you may need to run `deep` with sudo to reload it.

### 2) VPS: create app + config

`app.toml` defines the app’s port, domains, env, healthcheck defaults, and deploy defaults (image/source/quadlet dir). `deep apps add` generates a default config.

Deep looks for it in this order:

1. `--config <path>` if provided
2. `/srv/deep/apps/<app>/app.toml` (generated by `deep apps add`)
3. `<repo_path>/app.toml` (optional)
4. `./app.toml` (current directory)

```bash
deep apps add myapp
```

Edit `app.toml` and set your image prefix and domains before deploying.
CLI flags always override `app.toml` defaults.

Example `app.toml`:

```toml
[app]
name = "myapp"
port = 3000
domains = ["app.example.com"]

[healthcheck]
kind = "http"
path = "/health"
retries = 10
timeout_ms = 2000
interval_ms = 500
command = "wget -qO- http://127.0.0.1:3000/health >/dev/null"

# TCP healthchecks use [app].port; healthcheck.path is ignored.

[deploy]
# Registry workflow: set image or image_prefix/tag_strategy.
# image = "ghcr.io/me/myapp:latest" # pin a specific tag
git_ref = "HEAD"
image_prefix = "ghcr.io/me/myapp"
tag_strategy = "git_sha" # or "latest"
quadlet_dir = "/home/deploy/.config/containers/systemd"
# Git push workflow: set image_template to tag locally built images.
image_template = "ghcr.io/me/{{app}}:{{sha}}"
retain = 10

[env]
RUST_LOG = "info"
```

Pick one workflow in `app.toml`: keep `image`/`image_prefix` for registry deploys,
or keep `image_template` for git push deploys.

### 3) VPS: deploy an image

```bash
deep deploy myapp
```

If `[deploy].image` is not set in `app.toml`, pass `--image` explicitly:

```bash
deep deploy myapp --image ghcr.io/me/myapp:0123456789abcdef
```

`--git-sha` is optional. If omitted, Deep will try (in order):
1) the repo’s HEAD (if a git repo exists at `repo_path`), or
2) the image tag, or
3) `unknown`.

If `deploy.image_prefix` is set, Deep will build the image ref using
`deploy.tag_strategy` (`git_sha` or `latest`).

Healthchecks are still run by Deep at deploy time (before switching routes).
Quadlets provide restarts on crash. If you set `healthcheck.command`, Deep writes
`HealthCmd` into the quadlet so Podman can mark the container unhealthy.
TCP healthchecks use the app port from `[app].port`; `healthcheck.path` is ignored.

Note on images: `deploy.image`/`deploy.image_prefix` are for registry-based deploys.
`deploy.image_template` is only used by git push deploys to tag locally built images.

### 4) VPS: verify and rollback

```bash
deep releases current myapp
deep releases list myapp
deep rollback myapp <release_id>
```

## Workflows (two ways)

### Workflow A: registry image deploy

Laptop (build + push):

```bash
deep image publish \
  --image-prefix ghcr.io/me/myapp \
  --tag $(git rev-parse HEAD) \
  --tag latest
```

Alias: `deep image push ...`

VPS (deploy):

```bash
deep deploy myapp
```

Deep reads `app.toml` for the image prefix and tag strategy, resolves the image
digest, runs a healthcheck, updates Caddy, and records the release.

### Workflow B: git push deploy

VPS (prepare repo + hook):

```bash
deep apps add myapp --git
```

If `deploy.image_template` is set in `app.toml`, the hook uses it automatically.
Otherwise pass `--image-template` to define how the git SHA maps to an image tag.
Use either `image`/`image_prefix`/`tag_strategy` or `image_template` based on the workflow.

Laptop (push):

```bash
git remote add deep ssh://deploy@your-vps/srv/deep/repos/myapp.git
git push deep main
```

The `post-receive` hook reads the pushed SHA and runs:
`deep deploy myapp --git-sha <sha> --image <resolved-image>`.

Git push deploy always builds the image on the VPS (from the Dockerfile) before deploying.

## CLI usage (VPS)

Help and subcommand docs:

```bash
$ deep help
Deep micro-PaaS CLI

Usage: deep <COMMAND>

Commands:
  apps      Manage apps
  deploy    Deploy a new release
  releases  Inspect releases
  rollback  Roll back to a previous release
  logs      Stream logs for the current release
  addons    Manage addons and bindings
  proxy     Inspect and validate proxy routes
  host      Host setup and health checks
  git       Manage git hook integration
  image     Build and publish images (laptop workflow)
  help      Print this message or the help of the given subcommand(s)

Options:
  -h, --help     Print help
  -V, --version  Print version
```

### Image publish (laptop)

```bash
deep image publish --image-prefix ghcr.io/me/myapp --tag $(git rev-parse HEAD) --tag latest
```

If no `--tag` is provided, Deep resolves `--git-ref` (default: `HEAD`) and uses
that SHA plus `latest` as tags. Use `--no-push` to build and tag without pushing.

## app.toml reference

```toml
[app]
name = "myapp"
port = 3000
domains = ["app.example.com", "api.example.com"]

[healthcheck]
kind = "http" # or "tcp"
path = "/health"
retries = 10
timeout_ms = 2000
interval_ms = 500
command = "wget -qO- http://127.0.0.1:3000/health >/dev/null"

[deploy]
# Registry workflow: set image or image_prefix/tag_strategy.
# image = "ghcr.io/me/myapp:latest" # pin a specific tag
git_ref = "HEAD"
image_prefix = "ghcr.io/me/myapp"
tag_strategy = "git_sha"
quadlet_dir = "/home/deploy/.config/containers/systemd"
# Git push workflow: set image_template to tag locally built images.
image_template = "ghcr.io/me/{{app}}:{{sha}}"
retain = 10

[env]
RUST_LOG = "info"
FOO = "bar"
```

`deploy.image_template` is used by `deep apps add --git` and `deep git update-hook` when
creating or updating the post-receive hook. It is not used for registry-based deploys.

## Caddy config

Deep writes per-app blocks into a Caddyfile and reloads Caddy inside the container.

Defaults:

- Host Caddyfile: `/srv/deep/caddy/config/Caddyfile`
- Container Caddyfile: `/etc/caddy/Caddyfile`
- Container name: `deep-caddy`

Example (VPS, Podman quadlet):

```bash
deep host start-caddy
```

Notes:

- `/data` stores certificates and ACME state; keep it persistent across restarts.
- Deep writes routes between `# deep:app:<name>` markers.
- On reload failure, Deep restores the previous Caddyfile and retries reload.
- Caddy, apps, and addons are attached to `deep-net` so routes can use container names.
- If Caddy runs as a system unit, ensure `deep` can reload it (or run `deep` with sudo).
- Reloads are done via `systemctl reload <caddy.service>`, so the quadlet includes
  an `ExecReload` that runs `caddy reload`.

## Optional features

### Git push deploy (receiver hook)

```bash
deep apps add myapp --git
```

Creates the bare repo (if missing) and installs the hook. The hook always builds the image on the VPS from the Dockerfile before deploying.

Update hook template:

```bash
deep git update-hook myapp --image-template "ghcr.io/me/{{app}}:{{sha}}"
```

Use `deep git update-hook` when you change the image template, Dockerfile path,
or the `deep` binary path and want to re-render the hook.

Note: build-on-push requires `git` and `podman` on the VPS.

After `deep apps add --git`, you can add the VPS as a git remote and `git push`. The hook builds the image on the VPS before deploying.

### Addons

```bash
deep addons list
deep addons create postgres pg-main --config addon.toml
deep addons bind pg-main myapp
deep addons unbind pg-main myapp
deep addons destroy pg-main
deep addons start pg-main
deep addons stop pg-main
deep addons restart pg-main
```

Addon configs live in `/srv/deep/addons` by default, one file per addon
(`name.toml`). `deep addons create` writes/updates that file and the quadlet.
Use `--config-dir` to point at a different directory.

Addon config example:

```toml
kind = "postgres"
image = "postgres:16"
network = "deep-net"
volumes = ["/srv/deep/postgres:/var/lib/postgresql/data"]

[env]
POSTGRES_PASSWORD = "secret"

provision = [
  "psql -U postgres -d postgres -c \"create role app_user login password 'secret'\"",
  "psql -U postgres -d postgres -c \"create database app_db owner app_user\"",
]

export_env = ["POSTGRES_USER", "POSTGRES_PASSWORD", "POSTGRES_DB"]

[bind_env]
DATABASE_URL = "postgres://app_user:secret@deep-addon-pg-main:5432/app_db"

health_cmd = "pg_isready -U postgres"
health_interval_ms = 1000
health_timeout_ms = 1000
health_retries = 3
```

Addon quadlets are created under the current user’s quadlet directory by default
(`$HOME/.config/containers/systemd`). The config must include an `image`.
If you add `ports`, they will be published to the host; omit them to keep the
addon internal.

When an addon is bound, Deep runs any `provision` commands inside the addon
container, reads `export_env` from the container, merges `bind_env`, and restarts
the app to apply the new environment.

Provision commands can emit `KEY=VALUE` lines on stdout; Deep captures them and
injects those values into the app environment.
Commands run via `sh -lc` inside the addon container and receive `DEEP_APP` and
`DEEP_APP_ID` env variables.

## Quadlets for apps

Apps always run as per-release systemd quadlets. Each release becomes a unit named
`deep-app-<app>-<release_id>`. The quadlet directory defaults to
`$HOME/.config/containers/systemd` unless overridden by `deploy.quadlet_dir`.

## Development

```bash
cargo check
cargo test --tests
```
